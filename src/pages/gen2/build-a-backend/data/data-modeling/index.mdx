export const meta = {
  title: 'Customize your data model',
  description:
    'Learn how to customize your data model.'
};

export function getStaticProps(context) {
  return {
    props: {
      meta
    }
  };

}

## Identifiers
Identifiers are defined using the `.identifier()` method on a model definition. Its usage is optional, when it is not present, the model will automatically have a field called `id` of type `.autoUuid()` .

```typescript
const schema = a.schema({
  Todo: a.model({
    content: a.string(),
    completed: a.boolean(),
  })
});
```

```ts
const client = generateClient<Schema>();

const todo = await client.models.Todo.create({ content: 'Buy Milk', completed: false });
console.log(`New Todo created: ${todo.id}`); // New Todo created: 5DB6B4CC-CD41-49F5-9844-57C0AB506B69
```

If desired, TypeBeast allows you to define identifiers of the following types:
- Single field identifier
  - With a consumer provided value (type: `string`)
  - With an autogenerated value (type: `autoUuid`, `autoUlid`, `autoKsuid`)
- Composite identifier
  - With a consumer provided value (type: `string`)
  - With an autogenerated value (type: `autoUuid`, `autoUlid`, `autoKsuid`)

### Single field identifier

If the default `id` identifier field  needs to be customized, you can do so by passing the name of another field.

```typescript
const schema = a.schema({
  Todo: a.model({
    todoId: a.autoUuid(), // By specifying autoUuid instead of string, the field gets a value automatically
    title: a.string(),
    completed: a.boolean(),
  }).identifier('todoId')
});

const client = generateClient<Schema>();

const todo = await client.models.Todo.create({ title: 'Buy Milk', completed: false });
console.log(`New Todo created: ${todo.todoId}`); // New Todo created: 15C4B187-D08A-435C-BA32-417557AAC0EE
```

### Composite identifier

For cases where items are uniquely identified by more than a single field, you can pass an array of the field names to the `identifier()` function:

```typescript
const schema = a.schema({
  StoreBranch: a.model({
    tenantId: a.string(),
    name: a.string(),
    country: a.string(),
    state: a.string(),
    city: a.string(),
    zipCode: a.string(),
    streetAddress: a.string(),
  }).identifier(['tenantId', 'name'])
});

const client = generateClient<Schema>();

const branch = await client.models.StoreBranch.get({ tenantId: '123', name: 'Downtown' }); // All identifier fields are required when retrieving an item
```

# Add fields to data model

Amplify Data supports all AWS AppSync scalar types as fields. The following scalar types are available for every field:

|Field type|Description|TypeScript validation|GraphQL Scalar Type|
|-|-|-|-|
|`.id()`|A unique identifier for an object. This scalar is serialized like a String but isn't meant to be human-readable. If not specified on create operations, a ULID will be generated.|`string`|ID|
|`.string()`|A UTF-8 character sequence.|`string`|String|
|`.integer()`|An integer value between -(2^31) and 2^31-1.|`number` but rounded to closest integer value upon query/mutation|Int|
|`.float()`|An IEEE 754 floating point value.|`number`|Float|
|`.boolean()`|A Boolean value, either true or false.|`boolean`|Boolean|
|`.date()`|An extended ISO 8601 date string in the format YYYY-MM-DD.|`Date` but time information is cleared upon query/mutation|AWSDate|
|`.time()`|An extended ISO 8601 time string in the format hh:mm:ss.sss.|`Date` but date information is removed upon query/mutation|AWSTime|
|`.datetime()`|An extended ISO 8601 date and time string in the format YYYY-MM-DDThh:mm:ss.sssZ.|`Date`|AWSDateTime|
|`.timestamp()`|An integer value representing the number of seconds before or after 1970-01-01-T00:00Z.|`number`|AWSTimestamp|
|`.email()`|An email address in the format local-part@domain-part as defined by RFC 822.|`string` with local-part and domain-part type enforcement|AWSEmail|
|`.json()`|A JSON string. Any valid JSON construct is automatically parsed and loaded in the resolver code as maps, lists, or scalar values rather than as the literal input strings. Unquoted strings or otherwise invalid JSON result in a GraphQL validation error.|`any`|AWSJSON|
|`.phone()`|A phone number. This value is stored as a string. Phone numbers can contain either spaces or hyphens to separate digit groups. Phone numbers without a country code are assumed to be US/North American numbers adhering to the North American Numbering Plan.|`string` validation only happening service-side|AWSPhone|
|`.url()`|A URL as defined by RFC 1738. For example, https://www.amazon.com/dp/B000NZW3KC/ or mailto:example@example.com. URLs must contain a schema (http, mailto) and can't contain two forward slashes (//) in the path part.|`string` but with type enforcement on the schema part|AWSURL|
|`.ipAddress()`|A valid IPv4 or IPv6 address. IPv4 addresses are expected in quad-dotted notation (123.12.34.56). IPv6 addresses are expected in non-bracketed, colon-separated format (1a2b:3c4b::1234:4567). You can include an optional CIDR suffix (123.45.67.89/16) to indicate subnet mask.|`string` with type enforcement for IPv4 and IPv6 pattern|AWSIPAddress|


### Mark fields as required/optional
TK decide if the default should be required
By default, fields are optional to mark a field as required use the `.required()` modifier.

```ts
export const schema = a.schema({
  Todo: a.model({
    content: a.string().required()
  })
})
```

### Mark fields as arrays

Any field can be modified to be an array using the `.array()` modifier.
```ts
export const schema = a.schema({
  Todo: a.model({
    content: a.string().required()
    notes: a.string().array()
  })
})
```

### Specify a custom field type

Sometimes the built-in types do not meet the needs of your application requirements. In those cases you can specify custom types. You can either define the custom types inline or explicitly define the custom type in the schema.

Inline definition: The "location" field will be PascalCase-ed a new non-model type. If there are conflicts with another schema-level definition (model, custom type, enum), then you'll receive a Type error with a warning that you need to sift the value out as a separate item and use a "ref".
```ts
a.schema({
  Post: a.model({
    location: a.customType({
      lat: a.float(),
      long: a.float()
    }),
    content: string(),
  })
})
```

Explicit definition: Specify the "Location" as `a.customType()` in your schema. To use the custom type, reference it via `a.ref()` in the respective field definitions.

```ts
a.schema({
  Location: a.customType({
      lat: a.float(),
      long: a.float()
  }),

  Post: a.model({
    location: a.ref('Location'),
    content: a.string(),
  })

  User: a.model({
    lastKnownLocation: a.ref('Location')
  })
})
```

To set or read the location field on the client side, you can expand a nested object and the type system will auto-infer the allowed values.

```ts
const newPost = await client.Post.create({
  location: {
    lat: 48.837006,
    long: 8.282450
  }
})

console.log(newPost.location.lat, newPost.location.long)
```

### Specify an enum field type
Enum function in a similar developer experience as custom types, there are short-hand approaches and a long-form. To make building a dropdown UI easier, you can also retrieve all available enum options from your client code.

```ts
a.schema({
  Post: a.model({
    privacySetting: a.enum(['PRIVATE', 'FRIENDS_ONLY', 'PUBLIC'])
    content: string(),
  })
})
```

```ts
a.schema({
  PrivacySetting: a.enum([
    'PRIVATE',
    'FRIENDS_ONLY',
    'PUBLIC'
  ]),

  Post: a.model({
    content: string(),
    privacySetting: a.ref('PrivacySetting')
  })

  Video: a.model({
    privacySetting: a.ref('PrivacySetting')
  })
})
```

To retrieve all available dropdown options:

```ts
function PostConfig() {
  const enums = await client.PrivacySetting.values()
  return <select>
    {enums.map(enum => <option value={enum}>{enum}</option>)}
  </select>
}
```

When creating a new item client-side, the enums are also type-enforced:
```ts
client.Post.create({
  content: "hello",
  privacySetting: "PRIVATE" // <-- Works

  privacySetting: "NOT_PUBLIC" // <-- DOES NOT work
})
```

### Assign default values for fields

You can use the `.default(...)` modifier to specify a default value for optional [scalar type fields and arrays](https://docs.aws.amazon.com/appsync/latest/devguide/scalars.html).

```ts
export const schema = a.schema({
  Todo: a.model({
    content: a.string().default("My new Todo")
  })
})
```

> Note: `.default(...)` modifier can't be applied to required fields.
