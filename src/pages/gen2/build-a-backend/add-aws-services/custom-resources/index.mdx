export const meta = {
  title: 'Custom resources',
  description:
    'Learn how to write custom resources with the AWS CDK.'
};

export function getStaticProps(context) {
  return {
    props: {
      meta
    }
  };

}

Custom resources can be written using the [AWS Cloud Development Kit (CDK)](https://docs.aws.amazon.com/cdk/api/v2/).

From the [Concepts - AWS Cloud Development Kit (AWS CDK) v2](https://docs.aws.amazon.com/cdk/v2/guide/core_concepts.html) documentation

:::info

> AWS CDK apps are composed of building blocks known as [Constructs](https://docs.aws.amazon.com/cdk/v2/guide/constructs.html), which are composed together to form [stacks](https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.Stack.html) and [apps](https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.App.html).

:::

With the Amplify Code-first DX, you have the option to create individual [Constructs](https://docs.aws.amazon.com/cdk/v2/guide/constructs.html) and [Stacks](https://docs.aws.amazon.com/cdk/v2/guide/stacks.html) which will be composed into the [Backend](https://next-docs.amplify.aws/gen2/how-amplify-works/concepts/#backend) for your project.

## Defining a CDK Construct

:::info

> Constructs are the basic building blocks of AWS CDK apps. A construct represents a "cloud component" and encapsulates everything AWS CloudFormation needs to create the component. [Read more](https://docs.aws.amazon.com/cdk/v2/guide/constructs.html)

:::


Custom constructs allow you to encapsulate common patterns into reusable components. This helps you implement best practices, accelerate development, and maintain consistency across applications.

A common use case is creating a custom notification construct that combines a Lambda functions with SNS and SES.

This AWS CDK construct implements a decoupled notification system using Amazon SNS and Lambda. It allows publishing notification messages to an SNS topic from one Lambda function, and processing those messages asynchronously using a separate Lambda subscribed to the topic.

The key components are:

- An Amazon SNS topic to receive notification messages
- A Lambda function to publish messages to the SNS topic
- A second Lambda subscribed to the topic that processes the messages and sends emails via Amazon SES

The publisher Lambda allows publishing a message containing the email subject, body text, and recipient address. The emailer Lambda retrieves messages from the SNS topic and handles sending the actual emails.

The `CustomNotifications` custom CDK construct can be defined as follows:

```ts title="amplify/custom/CustomNotifications/resource.ts"
import { Runtime } from "aws-cdk-lib/aws-lambda";
import {
  NodejsFunction,
  NodejsFunctionProps,
} from "aws-cdk-lib/aws-lambda-nodejs";
import * as sns from "aws-cdk-lib/aws-sns";
import * as subs from "aws-cdk-lib/aws-sns-subscriptions";
import { Construct } from "constructs";
import { dirname, join } from "path";
import { fileURLToPath } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

export type Message = {
  subject: string;
  body: string;
  recipient: string;
};
interface CustomNotificationsProps {
  sourceAddress: string;
}

export class CustomNotifications extends Construct {
  constructor(scope: Construct, id: string, props: CustomNotificationsProps) {
    super(scope, id);

    const { sourceAddress } = props;

    // Create SNS topic
    const topic = new sns.Topic(this, "NotificationTopic");

    const nodeJsFunctionProps: NodejsFunctionProps = {
      bundling: {
        externalModules: [
          "aws-sdk", // Use the 'aws-sdk' available in the Lambda runtime
        ],
      },
      runtime: Runtime.NODEJS_18_X,
      handler: "index.handler",
    };

    // Lambda to publish messages
    const publisher = new NodejsFunction(this, "Publisher", {
      entry: join(__dirname, "publisher.ts"),
      environment: {
        topicArn: topic.topicArn,
      },
      ...nodeJsFunctionProps,
    });

    // Lambda to process messages
    const emailer = new NodejsFunction(this, "Emailer", {
      entry: join(__dirname, "emailer.ts"),
      environment: {
        sourceAddress,
      },
      ...nodeJsFunctionProps,
    });

    // Subscribe emailer lambda to SNS topic
    topic.addSubscription(new subs.LambdaSubscription(emailer));

    // Allow publisher to publish to SNS topic
    topic.grantPublish(publisher);
  }
}
```

The Lambda function code for the `Publisher` is:

```ts title="amplify/custom/CustomNotifications/publisher.ts"
// publisher Lambda
import { SNS } from "aws-sdk";
import { Message } from "./resource";

const topic = new SNS();

export const handler = async (event: any) => {
  try {
    const { subject, body, recipient } = event;

    const message = {
      subject,
      body,
      recipient,
    };

    // Publish message to SNS
    await topic.publish(message).promise();
  } catch (err) {
    console.error(err);
    throw err;
  }
};

```

```ts title="amplify/custom/CustomNotifications/emailer.ts"
// emailer Lambda
import { SNSEvent } from "@types/aws-lambda";
import { SNSHandler } from "aws-lambda";
import { SES, SNS } from "aws-sdk";
import { Message } from "./resource";

const topic = new SNS();
const ses = new SES();

export const handler: SNSHandler = async (event: SNSEvent) => {
  try {
    for (const record of event.Records) {
      const message = JSON.parse(record.Sns.Message);

      // Send email with SES
      await sendEmail(message);

      // Delete message from SNS
      await topic
        .deleteMessage({
          TopicArn: record.Sns.TopicArn,
          ReceiptHandle: record.Sns.ReceiptHandle,
        })
        .promise();
    }
  } catch (err) {
    console.error(err);
  }
};

const sendEmail = async (msg: Message) => {
  const { recipient, subject, body } = msg;

  const params = {
    Source: process.env.sourceAddress,
    Destination: {
      ToAddresses: [recipient],
    },
    Message: {
      Body: {
        Text: { Data: body },
      },
      Subject: { Data: subject },
    },
  };

  try {
    const result = await ses.sendEmail(params).promise();
    console.log(`Email sent to ${recipient}: ${result.MessageId}`);
  } catch (err) {
    console.error(`Error sending email to ${recipient}: ${err}`);
    throw err;
  }
};
```

The `CustomNotifications` CDK construct can then be added to the `backend` of the Amplify stack one or more times, with different props for each instance.

```ts title="amplify/backend.ts"
import { defineBackend } from '@aws-amplify/backend';
import { CustomNotifications } from './custom/CustomNotifications/resource';
import { data } from './data/resource';

const backend = new defineBackend({
  data,
});

new CustomNotifications(
  backend.getStack("CustomNotifications"),
  "CustomNotifications",
  { sourceAddress: "sender@example.com", }
);
```

:::note

Resources created by the `define*` helpers can only be accessed _after_ setting them on the `backend`

:::

## Defining a CDK Stack

:::info

> The unit of deployment in the AWS CDK is called a stack. All AWS resources defined within the scope of a stack, either directly or indirectly, are provisioned as a single unit. [Read more](https://docs.aws.amazon.com/cdk/v2/guide/stacks.html)

:::


The stack below contains a Lambda function that is deployed to a VPC. It is important that these resources be deployed as a singled unit instead of composed from other constructs as their functionality depends on one another.

```ts title="amplify/custom/LambdaInAVpcStack/resource.ts"
import {
  CfnOutput,
  Duration,
  Stack,
  StackProps,
  aws_ec2 as ec2,
  aws_lambda as lambda,
} from "aws-cdk-lib";
import { NodejsFunction } from "aws-cdk-lib/aws-lambda-nodejs";
import { Construct } from "constructs";
import { dirname, join } from "path";
import { fileURLToPath } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

export class LambdaInAVpcStack extends Stack {
  constructor(scope: Construct, id: string, props?: StackProps) {
    super(scope, id, props);

    const vpc = new ec2.Vpc(this, "LambdaVpc", {
      subnetConfiguration: [
        {
          name: "Isolated",
          subnetType: ec2.SubnetType.PRIVATE_ISOLATED,
        },
        {
          name: "Private",
          subnetType: ec2.SubnetType.PRIVATE_WITH_EGRESS,
        },
        {
          name: "Public",
          subnetType: ec2.SubnetType.PUBLIC,
        },
      ],
    });

    // Create a security group to be used on the lambda functions
    const lambdaSecurityGroup = new ec2.SecurityGroup(
      this,
      "Lambda Security Group",
      {
        vpc,
      }
    );

    const getDataLambda: NodejsFunction = new NodejsFunction(
      this,
      id + "-getDataLambda",
      {
        memorySize: 1024,
        timeout: Duration.seconds(5),
        runtime: lambda.Runtime.NODEJS_18_X,
        handler: "handler",
        entry: join(__dirname, "getData.ts"),
        vpc: vpc,
        vpcSubnets: { subnetType: ec2.SubnetType.PRIVATE_ISOLATED },
        securityGroups: [lambdaSecurityGroup],
      }
    );

    new CfnOutput(this, `${id}-getDataLambdaArn`, {
      value: getDataLambda.functionArn,
      exportName: `${id}-getDataLambdaArn`,
    });
  }
}
```

The Lambda function code for the `getDataLambda` is:

```ts title="amplify/custom/LambdaInAVpcStack/getData.ts"
import { APIGatewayProxyResultV2 } from "aws-lambda";

// example data; example data can be fetched from a database
const geoData = [
  {
    name: "United States",
    states: [
      "Alabama",
      "Alaska",
      "Arizona",
      //...
    ],
  },
];

export async function handler(): Promise<APIGatewayProxyResultV2> {
  try {
    return {
      statusCode: 200,
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(geoData, null, 2),
    };
  } catch (error) {
    console.error("Unable to connect to the database:", error);
    return {
      statusCode: 500,
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(error),
    };
  }
}
```

The custom CDK stack can then be added to the `backend`:

The `LambdaInAVpcStack` CDK Stack can then be added to the `backend` of the Amplify stack one or more times, with different props for each instance.

```ts title="amplify/backend.ts"
import { defineBackend } from '@aws-amplify/backend';
import { CustomNotifications } from './custom/CustomNotifications/resource';
import { data } from './data/resource';

const backend = new defineBackend({
  data,
});

new CustomNotifications(
  backend.getStack("CustomNotifications"),
  "CustomNotifications",
  { sourceAddress: "sender@example.com", }
);
```
