export const meta = {
  title: 'Custom resources',
  description:
    'Learn how to write custom resources with the AWS CDK.'
};

export function getStaticProps(context) {
  return {
    props: {
      meta
    }
  };

}

Custom resources can be written using the [AWS Cloud Development Kit (CDK)](https://docs.aws.amazon.com/cdk/api/v2/).

From the [Concepts - AWS Cloud Development Kit (AWS CDK) v2](https://docs.aws.amazon.com/cdk/v2/guide/core_concepts.html) documentation

:::info

> AWS CDK apps are composed of building blocks known as [Constructs](https://docs.aws.amazon.com/cdk/v2/guide/constructs.html), which are composed together to form [stacks](https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.Stack.html) and [apps](https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.App.html).

:::

With the Amplify Code-first DX, you have the option to create individual [Constructs](https://docs.aws.amazon.com/cdk/v2/guide/constructs.html) and [Stacks](https://docs.aws.amazon.com/cdk/v2/guide/stacks.html) which will be composed into the [Backend](https://next-docs.amplify.aws/gen2/how-amplify-works/concepts/#backend) for your project.

## Defining a CDK Construct

:::info

> Constructs are the basic building blocks of AWS CDK apps. A construct represents a "cloud component" and encapsulates everything AWS CloudFormation needs to create the component. [Read more](https://docs.aws.amazon.com/cdk/v2/guide/constructs.html)

:::


Here is an explanation of why a customer would want to define a Custom construct in and an example use case:

Custom constructs allow you to encapsulate common patterns into reusable components. This helps you implement best practices, accelerate development, and maintain consistency across applications.

A common use case is creating a custom notification construct that combines a Lambda function with SNS and SES. For example, the construct would:

- Create a Lambda function that is triggered by some event like a data update
- The Lambda would publish a message to an SNS topic
- An email subscription to the SNS topic can be added that leverages SES to send an email notification on the event

The `CustomNotifications` custom CDK construct can be defined as follows:

```ts title="amplify/custom/CustomNotifications.ts"
import { Runtime } from "aws-cdk-lib/aws-lambda";
import { NodejsFunction } from "aws-cdk-lib/aws-lambda-nodejs";
import { Topic } from "aws-cdk-lib/aws-sns";
import {
  EmailSubscription,
  LambdaSubscription,
} from "aws-cdk-lib/aws-sns-subscriptions";
import { Construct } from "constructs";
import { dirname, join } from "path";
import { fileURLToPath } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

interface CustomNotificationsProps {
  emailSubscription: string;
  sourceAddress: string;
  recipientAddress: string;
  emailSubject?: string;
}

export class CustomNotifications extends Construct {
  constructor(scope: Construct, id: string, props: CustomNotificationsProps) {
    const { emailSubscription, sourceAddress, recipientAddress, emailSubject } =
      props;

    super(scope, id);

    const topic = new Topic(this, "NotificationTopic");

    const lambda = new NodejsFunction(this, "NotificationHandler", {
      runtime: Runtime.NODEJS_18_X,
      handler: "index.handler",
      entry: join(__dirname, "index.ts"),
      functionName: "notificationHandler",
      bundling: {
        externalModules: [
          "aws-sdk", // Use the 'aws-sdk' available in the Lambda runtime
        ],
      },
      environment: {
        topicArn: topic.topicArn,
        recipientAddress,
        sourceAddress,
        emailSubject: emailSubject || "Notification email",
      },
    });

    topic.addSubscription(new LambdaSubscription(lambda));
    topic.addSubscription(new EmailSubscription(emailSubscription));
  }
}
```

The Lambda function code can be defined as follows:

```ts title="amplify/custom/index.ts"
import { SNSEvent } from "aws-lambda";
import AWS from "aws-sdk";

// Initialize AWS SDK clients
const sns = new AWS.SNS();
const ses = new AWS.SES();

// Lambda handler
exports.handler = async (event: SNSEvent) => {
  // Get message content
  const message = event.Records[0].Sns.Message;

  // Log received message
  console.log("Received SNS message:", message);

  // Publish message to another SNS topic
  await publishMessage(message);

  // Send email
  await sendEmail(message);

  return { status: "success" };
};

// Publish to SNS
const publishMessage = async (msg: string) => {
  const params = {
    TopicArn: process.env.topicArn,
    Message: msg,
  };

  await sns.publish(params).promise();
};

// Send email via SES
const sendEmail = async (msg: string) => {
  const params = {
    Source: process.env.sourceAddress,
    Destination: {
      ToAddresses: [process.env.recipientAddress],
    },
    Message: {
      Body: {
        Text: { Data: msg },
      },
      Subject: { Data: process.env.emailSubject },
    },
  };

  await ses.sendEmail(params).promise();
};
```

The `CustomNotifications` CDK construct can then be added to the `backend` of the Amplify stack one or more times, with different props for each instance.

```ts title="amplify/backend.ts"
import { defineBackend } from '@aws-amplify/backend';
import { CustomNotifications } from './custom/CustomNotifications';
import { data } from './data/resource';

const backend = new defineBackend({
  data,
});

new CustomNotifications(
  backend.getStack("CustomNotifications"),
  "CustomNotifications",
  {
    emailSubscription: "email@example.com",
    sourceAddress: "sender@example.com",
    recipientAddress: "recipient@example.com",
  }
);
```

:::note

Resources created by the `define*` helpers can only be accessed _after_ setting them on the `backend`

:::

## Defining a CDK Stack

:::info

> The unit of deployment in the AWS CDK is called a stack. All AWS resources defined within the scope of a stack, either directly or indirectly, are provisioned as a single unit. [Read more](https://docs.aws.amazon.com/cdk/v2/guide/stacks.html)

:::

```ts title="amplify/custom/BackupStack.ts"
import { Construct } from 'constructs';
import * as cdk from 'aws-cdk-lib';
import * as backup from 'aws-cdk-lib/aws-backup';
import * as events from 'aws-cdk-lib/aws-events';
import * as rds from 'aws-cdk-lib/aws-rds';

/**
 * Define the stack's props
 */
export type BackupStackProps = cdk.StackProps & {
  /**
   * Database instance to back up
   */
  database: rds.DatabaseInstance;
};

/**
 * Configure an "BackupStack" to backup DynamoDB Tables created by `data`
 */
export class BackupStack extends cdk.Stack {
  constructor(scope: Construct, id: string, props: BackupStackProps) {
    super(scope, id, props);

    const { database } = props;

    // create the backup plan
    const plan = new backup.BackupPlan(this, 'BackupPlan', {
      backupPlanRules: [
        new backup.BackupPlanRule({
          completionWindow: cdk.Duration.hours(2),
          startWindow: cdk.Duration.hours(1),
          scheduleExpression: events.Schedule.cron({
            day: '15',
            hour: '3',
            minute: '30',
          }),
          moveToColdStorageAfter: cdk.Duration.days(30),
        }),
      ],
    });

    // add the database to the backup plan
    plan.addSelection('Selection', {
      resources: [backup.BackupResource.fromRdsDatabaseInstance(database)],
    });
  }
}
```

The custom CDK stack can then be added to the `backend`:

```ts title="amplify/backend.ts"
import { Backend } from '@aws-amplify/backend';
import { BackupStack } from './custom/BackupStack';
import { data } from './data/resource';

const backend = new defineBackend({
  data,
});

// construct BackupStack using the backend's root CloudFormation stack as the scope
new BackupStack(backend.getStack('BackupStack'), 'Backup', {
  database: backend.data.resources.database,
});
```
